import { app, BrowserWindow, globalShortcut, ipcMain, Tray, Menu, nativeImage, clipboard, desktopCapturer, screen, shell, systemPreferences, session, dialog } from 'electron';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

// ÂºÇÂ∏∏ÊçïËé∑ÔºöÈò≤Ê≠¢Á®ãÂ∫èÁõ¥Êé•Â¥©Ê∫É
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  try {
    const logPath = path.join(app.getPath('userData'), 'crash.log');
    fs.appendFileSync(logPath, `[${new Date().toISOString()}] CRASH: ${error.stack}\n`);
  } catch (e) {
    console.error('Failed to write crash log:', e);
  }
  // Â∞ùËØïÂºπÁ™óÔºàÂ¶ÇÊûúÊúâÊ¥ªÂä®Á™óÂè£Ôºâ
  if (app.isReady() && !app.isQuiting) { // ‰øÆÊ≠£: isQuiting -> isQuitting (but electron app property is custom?) electron has 'before-quit' etc. safest is just check ready
    // Electron dialog.showErrorBox is safe to call after ready
    try {
      dialog.showErrorBox('ScreenCap Pro ÈîôËØØ', `ÂèëÁîüÊÑèÂ§ñÈîôËØØÔºö\n${error.message}\nËØ∑Êü•Áúã crash.log`);
    } catch (e) { }
  }
});

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// CRITICAL FIX: Polyfill global.__dirname for dependencies like fluent-ffmpeg/ffmpeg-static
(global as any).__dirname = __dirname;

// ÂçïÂÆû‰æãÈîÅÂÆöÔºöÁ°Æ‰øùÂè™Êúâ‰∏Ä‰∏™Á®ãÂ∫èÂÆû‰æãÂú®ËøêË°å
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
  app.quit();
} else {
  app.on('second-instance', () => {
    // ÂΩìÁî®Êà∑Â∞ùËØïÂêØÂä®Á¨¨‰∫å‰∏™ÂÆû‰æãÊó∂ÔºåÊòæÁ§∫‰∏Ä‰∏™ÊèêÁ§∫ÈÄöÁü•
    try {
      if (screen) {
        showNotification('Á®ãÂ∫èÂ∑≤Âú®ÂêéÂè∞ËøêË°å', { x: screen.getPrimaryDisplay().bounds.width / 2, y: screen.getPrimaryDisplay().bounds.height / 2 });
      }
    } catch (e) { }
  });
}

interface AppSettings {
  savePath: string;
  imageFormat: 'png' | 'jpg';
  videoFormat: 'mp4' | 'webm';
  audioSource: 'none' | 'system' | 'mic';
  frameRate: 30 | 60 | 90;
  shortcutMode: 'standard' | 'alternative';
  openAtLogin: boolean;
}

const SETTINGS_PATH = path.join(app.getPath('userData'), 'settings.json');

function loadSettings(): AppSettings {
  const defaultSettings: AppSettings = {
    savePath: app.getPath('desktop'),
    imageFormat: 'png',
    videoFormat: 'mp4',
    audioSource: 'system',
    frameRate: 60,
    shortcutMode: 'standard',
    openAtLogin: true // ÈªòËÆ§ÂºÄÂêØ
  };

  try {
    if (fs.existsSync(SETTINGS_PATH)) {
      const data = fs.readFileSync(SETTINGS_PATH, 'utf-8');
      return { ...defaultSettings, ...JSON.parse(data) };
    }
  } catch (e) {
    console.error('Failed to load settings:', e);
  }
  return defaultSettings;
}

function saveSettings(newSettings: AppSettings) {
  try {
    fs.writeFileSync(SETTINGS_PATH, JSON.stringify(newSettings, null, 2));
  } catch (e) {
    console.error('Failed to save settings:', e);
  }
}

let settings: AppSettings = loadSettings();

// Apply initial login item settings
app.setLoginItemSettings({
  openAtLogin: settings.openAtLogin,
  openAsHidden: false
});

// 1. Èò≤Ê≠¢ÂêéÂè∞ËäÇÊµÅ - ÂÖ≥ÈîÆÔºÅ
app.commandLine.appendSwitch('disable-renderer-backgrounding');
app.commandLine.appendSwitch('disable-background-timer-throttling');
app.commandLine.appendSwitch('disable-backgrounding-occluded-windows');

// 2. GPU Á°¨‰ª∂Âä†ÈÄü - Âä†Âø´Êà™ÂõæÈÄüÂ∫¶
app.commandLine.appendSwitch('enable-gpu-rasterization');
app.commandLine.appendSwitch('enable-zero-copy');
app.commandLine.appendSwitch('enable-features', 'VaapiVideoDecoder,VaapiVideoEncoder');

// ËæÖÂä©ÂáΩÊï∞ÔºöËé∑ÂèñËµÑÊ∫êÊñá‰ª∂ÁöÑÊ≠£Á°ÆË∑ØÂæÑÔºàÂÖºÂÆπÂºÄÂèëÂíåÊâìÂåÖÁéØÂ¢ÉÔºâ
function getResourcePath(relativePath: string): string {
  // app.getAppPath() Âú®ÊâìÂåÖÂêéËøîÂõû .../resources/app.asar
  return path.join(app.getAppPath(), relativePath);
}

let tray: Tray | null = null;
let selectorWindow: BrowserWindow | null = null;
let recorderWindow: BrowserWindow | null = null;
let notificationWindow: BrowserWindow | null = null;
let isRecording = false;

// È¢ÑÁÉ≠ÁöÑÈÄâÊã©Âô®Á™óÂè£ÔºàÈöêËóèÁä∂ÊÄÅÔºåÁî®‰∫éÂä†Âø´ F1/F2 ÂìçÂ∫îÈÄüÂ∫¶Ôºâ
let prewarmedSelectorWindow: BrowserWindow | null = null;

// Êà™ÂõæÁºìÂ≠òÔºöÁî®‰∫é„ÄåÂ±èÂπïÂÜªÁªì„ÄçÊ®°Âºè (F1/F2)
let cachedScreenshot: { dataUrl: string; nativeImage: Electron.NativeImage; width: number; height: number; scaleFactor: number } | null = null;

// ÂàõÂª∫È¢ÑÁÉ≠ÁöÑÈÄâÊã©Âô®Á™óÂè£ÔºàÈöêËóèÁä∂ÊÄÅÔºâ
function createPrewarmedSelectorWindow() {
  if (prewarmedSelectorWindow && !prewarmedSelectorWindow.isDestroyed()) {
    return; // Â∑≤Â≠òÂú®Âàô‰∏çÈáçÂ§çÂàõÂª∫
  }

  const display = screen.getPrimaryDisplay();
  const { width, height } = display.bounds;

  prewarmedSelectorWindow = new BrowserWindow({
    x: 0,
    y: 0,
    width: width,
    height: height,
    show: false, // ÂÖ≥ÈîÆÔºöÂàõÂª∫Êó∂ÈöêËóè
    transparent: true,
    frame: false,
    enableLargerThanScreen: true,
    alwaysOnTop: true,
    skipTaskbar: true,
    resizable: true,
    focusable: true, // F1/F2 ÈúÄË¶Å
    movable: false,
    hasShadow: false,
    fullscreenable: false,
    maximizable: false,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
      sandbox: false,
      zoomFactor: 1.0,
      backgroundThrottling: false // Èò≤Ê≠¢ÂêéÂè∞ËäÇÊµÅ
    },
    icon: getResourcePath('public/icon.png')
  });

  // È¢ÑÂä†ËΩΩÈ°µÈù¢Ôºà‰ΩøÁî® clipboard Ê®°ÂºèÔºâ
  const url = process.env.VITE_DEV_SERVER_URL
    ? `${process.env.VITE_DEV_SERVER_URL}?mode=clipboard`
    : `file://${path.join(__dirname, '../dist/index.html')}?mode=clipboard`;

  prewarmedSelectorWindow.loadURL(url);

  prewarmedSelectorWindow.on('closed', () => {
    prewarmedSelectorWindow = null;
    // ÂÖ≥Èó≠ÂêéÈáçÊñ∞ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÈ¢ÑÁÉ≠Á™óÂè£
    setTimeout(() => createPrewarmedSelectorWindow(), 100);
  });

  console.log('[Main] Prewarmed selector window created');
}

// ÂàõÂª∫ÂêéÂè∞ÂΩïÂà∂Á™óÂè£
function createRecorderWindow() {
  recorderWindow = new BrowserWindow({
    show: false,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
      backgroundThrottling: false, // Èò≤Ê≠¢ÂêéÂè∞Ë¢´ÂÜªÁªì
      sandbox: false
    },
    icon: getResourcePath('public/icon.png')
  });

  const url = process.env.VITE_DEV_SERVER_URL
    ? `${process.env.VITE_DEV_SERVER_URL}?mode=recorder`
    : `file://${path.join(__dirname, '../dist/index.html')}?mode=recorder`;

  recorderWindow.loadURL(url);

  // ‰ªÖÂú® macOS ‰∏äËØ∑Ê±ÇÊùÉÈôê
  if (process.platform === 'darwin') {
    systemPreferences.askForMediaAccess('microphone');
  }

  // Ë∞ÉËØïÊó•Âøó
  recorderWindow.webContents.on('console-message', (e, level, msg) => {
    console.log('[Recorder]:', msg);
  });
}

function showNotification(message: string, mousePos: { x: number, y: number }) {
  if (notificationWindow && !notificationWindow.isDestroyed()) {
    notificationWindow.destroy();
  }

  const notifWidth = 140;
  const notifHeight = 36;

  let x = mousePos.x - notifWidth / 2;
  let y = mousePos.y - notifHeight - 20;

  try {
    const { width, height } = screen.getPrimaryDisplay().bounds;
    if (x < 10) x = 10;
    if (x + notifWidth > width - 10) x = width - notifWidth - 10;
    if (y < 10) y = mousePos.y + 30;

    notificationWindow = new BrowserWindow({
      width: notifWidth,
      height: notifHeight,
      x: Math.round(x),
      y: Math.round(y),
      frame: false,
      transparent: true,
      alwaysOnTop: true,
      skipTaskbar: true,
      focusable: false,
      resizable: false,
      hasShadow: false,
      webPreferences: { nodeIntegration: false, contextIsolation: true },
      icon: getResourcePath('public/icon.png')
    });

    notificationWindow.setIgnoreMouseEvents(true);

    const html = `<!DOCTYPE html><html><head><style>
        *{margin:0;padding:0;box-sizing:border-box}
        html,body{overflow:hidden}
        body{display:flex;align-items:center;justify-content:center;height:100vh;background:transparent;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif}
        .pill{
        display:flex;align-items:center;gap:6px;
        background:rgba(30,30,30,0.75);
        backdrop-filter:blur(12px);
        -webkit-backdrop-filter:blur(12px);
        color:rgba(220,220,220,0.95);
        padding:8px 16px;
        border-radius:20px;
        font-size:13px;
        font-weight:500;
        letter-spacing:0.3px;
        border:1px solid rgba(255,255,255,0.1);
        box-shadow:0 4px 16px rgba(0,0,0,0.3);
        animation:pop 0.6s cubic-bezier(0.34,1.56,0.64,1);
        }
        .check{width:14px;height:14px;fill:rgba(160,160,160,0.9)}
        @keyframes pop{
        0%{opacity:0;transform:scale(0.85) translateY(8px)}
        100%{opacity:1;transform:scale(1) translateY(0)}
        }
    </style></head><body>
        <div class="pill">
        <svg class="check" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/></svg>
        <span>${message}</span>
        </div>
    </body></html>`;

    notificationWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(html)}`);

    setTimeout(() => {
      try {
        if (notificationWindow && !notificationWindow.isDestroyed()) {
          notificationWindow.destroy();
          notificationWindow = null;
        }
      } catch (e) { }
    }, 800);
  } catch (e) {
    console.error('showNotification error:', e);
  }
}

function closeSelectorWindow() {
  if (selectorWindow && !selectorWindow.isDestroyed()) {
    selectorWindow.destroy();
    selectorWindow = null;
  }
  globalShortcut.unregister('Escape');
  // Ê∏ÖÈô§Êà™ÂõæÁºìÂ≠ò
  cachedScreenshot = null;
}

// È¢ÑÊà™ÂõæÂáΩÊï∞ÔºöÂú®ÂàõÂª∫Á™óÂè£ÂâçÊà™ÂèñÂÖ®Â±èÔºàÁî®‰∫é F1/F2 ÂÜªÁªìÊ®°ÂºèÔºâ
async function captureScreenBeforeSelector(): Promise<string | null> {
  const startTime = Date.now();
  try {
    const display = screen.getPrimaryDisplay();
    const { width, height } = display.bounds; // ÈÄªËæëÂàÜËæ®ÁéáÔºåÂ¶Ç 1920x1080
    const scaleFactor = display.scaleFactor;   // Â¶Ç 2.0 (4K)

    // ‰ΩøÁî®ÂéüÁîüÂàÜËæ®ÁéáÊà™Âõæ‰ª•‰øùËØÅÈ´òÊ∏ÖÊô∞Â∫¶
    const thumbSize = {
      width: Math.round(width * scaleFactor),
      height: Math.round(height * scaleFactor)
    };

    const captureStart = Date.now();
    const sources = await desktopCapturer.getSources({
      types: ['screen'],
      thumbnailSize: thumbSize
    });
    console.log(`[Main] desktopCapturer took: ${Date.now() - captureStart}ms`);

    if (!sources[0]) return null;

    const nativeImg = sources[0].thumbnail;

    const dataUrlStart = Date.now();
    // ‰ΩøÁî® JPEG Ê†ºÂºèÂáèÂ∞è‰ΩìÁßØÔºåË¥®ÈáèËÆæ‰∏∫ 90%
    const dataUrl = nativeImg.toDataURL({ scaleFactor: 1.0 });
    console.log(`[Main] toDataURL took: ${Date.now() - dataUrlStart}ms`);

    // ÁºìÂ≠òÊà™ÂõæÔºö‰øùÂ≠òÂéüÁîüÂõæÂÉèÁî®‰∫éË£ÅÂâ™Ôºå‰øùÂ≠òÈÄªËæëÂàÜËæ®Áéá‰æõÂùêÊ†áËÆ°ÁÆó
    cachedScreenshot = {
      dataUrl,
      nativeImage: nativeImg,
      width,  // ÈÄªËæëÂàÜËæ®Áéá
      height,
      scaleFactor
    };

    console.log(`[Main] Total screenshot time: ${Date.now() - startTime}ms (native: ${thumbSize.width}x${thumbSize.height}, logical: ${width}x${height})`);
    return dataUrl;
  } catch (e) {
    console.error('captureScreenBeforeSelector error:', e);
    return null;
  }
}

async function createSelectorWindow(mode: 'clipboard' | 'file' | 'record') {
  const startTime = Date.now();

  // ÂÖ≥Èó≠Áé∞ÊúâÁ™óÂè£
  if (selectorWindow && !selectorWindow.isDestroyed()) {
    selectorWindow.destroy();
    selectorWindow = null;
  }
  globalShortcut.unregister('Escape');

  const display = screen.getPrimaryDisplay();
  const { width, height } = display.bounds;

  // F1/F2 Êà™ÂõæÊ®°ÂºèÔºöÂπ∂Ë°åÂ§ÑÁêÜÊà™ÂõæÂíåÁ™óÂè£ÂáÜÂ§á
  if (mode === 'clipboard' || mode === 'file') {
    // ‰ΩøÁî®È¢ÑÁÉ≠Á™óÂè£ÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
    if (prewarmedSelectorWindow && !prewarmedSelectorWindow.isDestroyed()) {
      console.log('[Main] Using prewarmed selector window');
      selectorWindow = prewarmedSelectorWindow;
      prewarmedSelectorWindow = null;

      // Âπ∂Ë°åÔºöÊà™Âõæ + Á™óÂè£ÂáÜÂ§á
      const screenshotPromise = captureScreenBeforeSelector();

      // Á™óÂè£ÂáÜÂ§áÔºàÂ∑≤È¢ÑÂä†ËΩΩÔºåÂè™ÈúÄÈÖçÁΩÆÔºâ
      selectorWindow.setAlwaysOnTop(true, 'screen-saver', 1);
      selectorWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
      selectorWindow.setBounds({ x: 0, y: 0, width, height });

      // Á≠âÂæÖÊà™ÂõæÂÆåÊàê
      const screenshotDataUrl = await screenshotPromise;

      if (screenshotDataUrl) {
        selectorWindow.webContents.send('init-screenshot', screenshotDataUrl);
      }

      // ÊòæÁ§∫Á™óÂè£
      selectorWindow.show();
      selectorWindow.focus();
      selectorWindow.moveTop();

      console.log(`[Main] Fast path total time: ${Date.now() - startTime}ms`);

      // ÂêéÂè∞ÂàõÂª∫Êñ∞ÁöÑÈ¢ÑÁÉ≠Á™óÂè£
      setTimeout(() => createPrewarmedSelectorWindow(), 50);

    } else {
      // ÂõûÈÄÄÔºöÊ≤°ÊúâÈ¢ÑÁÉ≠Á™óÂè£Ôºå‰ΩøÁî®‰º†ÁªüÊñπÂºè
      console.log('[Main] No prewarmed window, using fallback');
      const screenshotDataUrl = await captureScreenBeforeSelector();

      selectorWindow = new BrowserWindow({
        x: 0, y: 0, width, height,
        transparent: true,
        frame: false,
        enableLargerThanScreen: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        resizable: true,
        focusable: true,
        movable: false,
        hasShadow: false,
        fullscreenable: false,
        maximizable: false,
        webPreferences: {
          preload: path.join(__dirname, 'preload.js'),
          contextIsolation: true,
          nodeIntegration: false,
          sandbox: false,
          zoomFactor: 1.0
        },
        icon: getResourcePath('public/icon.png')
      });

      selectorWindow.setAlwaysOnTop(true, 'screen-saver', 1);
      selectorWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
      selectorWindow.setBounds({ x: 0, y: 0, width, height });

      if (screenshotDataUrl) {
        selectorWindow.webContents.once('dom-ready', () => {
          if (selectorWindow && !selectorWindow.isDestroyed()) {
            selectorWindow.webContents.send('init-screenshot', screenshotDataUrl);
          }
        });
      }

      const url = process.env.VITE_DEV_SERVER_URL
        ? `${process.env.VITE_DEV_SERVER_URL}?mode=${mode}`
        : `file://${path.join(__dirname, '../dist/index.html')}?mode=${mode}`;
      selectorWindow.loadURL(url);
    }

  } else {
    // F3 ÂΩïÂ±èÊ®°ÂºèÔºö‰ΩøÁî®ÂéüÊúâÈÄªËæë
    selectorWindow = new BrowserWindow({
      x: 0, y: 0, width, height,
      transparent: true,
      frame: false,
      enableLargerThanScreen: true,
      alwaysOnTop: true,
      skipTaskbar: true,
      resizable: true,
      focusable: false, // ÂΩïÂ±èÊ®°Âºè‰∏çËé∑ÂèñÁÑ¶ÁÇπ
      movable: false,
      hasShadow: false,
      fullscreenable: false,
      maximizable: false,
      webPreferences: {
        preload: path.join(__dirname, 'preload.js'),
        contextIsolation: true,
        nodeIntegration: false,
        sandbox: false,
        zoomFactor: 1.0
      },
      icon: getResourcePath('public/icon.png')
    });

    selectorWindow.setAlwaysOnTop(true, 'screen-saver', 1);
    selectorWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
    selectorWindow.setContentProtection(true);
    selectorWindow.setBounds({ x: 0, y: 0, width, height });

    // Z-ORDER Áª¥Êä§Âæ™ÁéØ
    const zOrderInterval = setInterval(() => {
      if (selectorWindow && !selectorWindow.isDestroyed()) {
        try {
          selectorWindow.moveTop();
          selectorWindow.setAlwaysOnTop(true, 'screen-saver', 1);
        } catch (e) { }
      }
    }, 20);

    selectorWindow.on('closed', () => {
      clearInterval(zOrderInterval);
    });

    const url = process.env.VITE_DEV_SERVER_URL
      ? `${process.env.VITE_DEV_SERVER_URL}?mode=record`
      : `file://${path.join(__dirname, '../dist/index.html')}?mode=record`;
    selectorWindow.loadURL(url);

    if (process.platform === 'darwin') {
      systemPreferences.askForMediaAccess('microphone');
    }
  }

  selectorWindow.on('closed', () => {
    selectorWindow = null;
    cachedScreenshot = null;
  });

  selectorWindow.setIgnoreMouseEvents(false);

  setTimeout(() => {
    if (selectorWindow && !selectorWindow.isDestroyed()) {
      selectorWindow.setBounds({ x: 0, y: 0, width, height });
      selectorWindow.moveTop();
      selectorWindow.setAlwaysOnTop(true, 'screen-saver', 1);
    }
  }, 50);

  return selectorWindow;
}

function registerShortcuts() {
  try {
    globalShortcut.unregisterAll();
    console.log(`[Main] Registering shortcuts in mode: ${settings.shortcutMode}`);

    const registerOne = (accelerator: string, callback: () => void) => {
      try {
        const success = globalShortcut.register(accelerator, callback);
        if (!success) {
          console.error(`Global shortcut registration failed: ${accelerator}`);
          try {
            showNotification(`Ê≥®ÂÜåÂ§±Ë¥•: ${accelerator} Ë¢´Âç†Áî®`, { x: screen.getPrimaryDisplay().bounds.width / 2, y: screen.getPrimaryDisplay().bounds.height / 2 });
          } catch (e) { console.error('Notify failed:', e); }
        } else {
          console.log(`Global shortcut registered: ${accelerator}`);
        }
      } catch (e) {
        console.error(e);
      }
    };

    const actions = {
      clipboard: () => createSelectorWindow('clipboard'),
      file: () => createSelectorWindow('file'),
      record: () => {
        console.log('[Main] Record Shortcut Pressed');
        if (isRecording) {
          try {
            showNotification('Ê≠£Âú®ÂÅúÊ≠¢ÂΩïÂà∂...', { x: screen.getPrimaryDisplay().bounds.width / 2, y: screen.getPrimaryDisplay().bounds.height / 2 });
          } catch (e) { }
          if (recorderWindow) recorderWindow.webContents.send('stop-recording');
          if (selectorWindow) selectorWindow.webContents.send('stop-recording');
        } else {
          try {
            showNotification('ÂáÜÂ§áÂºÄÂßãÂΩïÂà∂...', { x: screen.getPrimaryDisplay().bounds.width / 2, y: screen.getPrimaryDisplay().bounds.height / 2 });
          } catch (e) { }
          createSelectorWindow('record');
          isRecording = true;
        }
      }
    };

    if (settings.shortcutMode === 'standard') {
      registerOne('F1', actions.clipboard);
      registerOne('F2', actions.file);
      registerOne('F3', actions.record);
    } else {
      registerOne('Alt+F1', actions.clipboard);
      registerOne('Alt+F2', actions.file);
      registerOne('Alt+F3', actions.record);
    }
  } catch (e) {
    console.error('registerShortcuts error:', e);
  }
}

function createTray() {
  try {
    const updateSettings = (key: keyof AppSettings, value: any) => {
      (settings as any)[key] = value;
      createTray();
      if (key === 'shortcutMode') {
        registerShortcuts();
        try {
          showNotification(`Â∑≤ÂàáÊç¢Ê®°Âºè: ${value === 'standard' ? 'Ê†áÂáÜ' : 'Èò≤ÂÜ≤Á™Å'}`, { x: screen.getPrimaryDisplay().bounds.width / 2, y: screen.getPrimaryDisplay().bounds.height / 2 });
        } catch (e) { }
      }
    };

    const getShortcutLabel = (base: string) => {
      const prefix = settings.shortcutMode === 'standard' ? '' : 'Alt+';
      return `${prefix}${base}`;
    };

    const menu = Menu.buildFromTemplate([
      { label: 'ScreenCap Pro', enabled: false },
      { type: 'separator' },
      { label: `Êà™ÂõæÂà∞Ââ™Ë¥¥Êùø (${getShortcutLabel('F1')})`, click: () => createSelectorWindow('clipboard') },
      { label: `Êà™ÂõæÂà∞Êñá‰ª∂ (${getShortcutLabel('F2')})`, click: () => createSelectorWindow('file') },
      { label: `ÂΩïÂ±è (${getShortcutLabel('F3')})`, click: () => { if (!isRecording) { createSelectorWindow('record'); isRecording = true; } } },
      { type: 'separator' },
      {
        label: '‚å®Ô∏è Âø´Êç∑ÈîÆÊ®°Âºè',
        submenu: [
          {
            label: 'Ê†áÂáÜ (F1 / F2 / F3)',
            type: 'radio',
            checked: settings.shortcutMode === 'standard',
            click: () => updateSettings('shortcutMode', 'standard')
          },
          {
            label: 'Èò≤ÂÜ≤Á™Å (Alt + F1/2/3)',
            type: 'radio',
            checked: settings.shortcutMode === 'alternative',
            click: () => updateSettings('shortcutMode', 'alternative')
          }
        ]
      },
      { type: 'separator' },
      {
        label: 'üîä Èü≥È¢ëÊ∫ê',
        submenu: [
          { label: 'Êó†', type: 'radio', checked: settings.audioSource === 'none', click: () => updateSettings('audioSource', 'none') },
          { label: 'Á≥ªÁªüÂ£∞Èü≥', type: 'radio', checked: settings.audioSource === 'system', click: () => updateSettings('audioSource', 'system') },
          { label: 'È∫¶ÂÖãÈ£é', type: 'radio', checked: settings.audioSource === 'mic', click: () => updateSettings('audioSource', 'mic') }
        ]
      },
      { type: 'separator' },
      {
        label: 'ÂºÄÊú∫Ëá™ÂêØ',
        type: 'checkbox',
        checked: settings.openAtLogin,
        click: () => {
          const newValue = !settings.openAtLogin;
          updateSettings('openAtLogin', newValue);
          saveSettings(settings); // ‰øùÂ≠òËÆæÁΩÆ
          app.setLoginItemSettings({
            openAtLogin: newValue,
            openAsHidden: false
          });
        }
      },
      { type: 'separator' },
      { label: 'ÊâìÂºÄ‰øùÂ≠òÁõÆÂΩï', click: () => shell.openPath(settings.savePath) },
      { type: 'separator' },
      { label: 'ÈÄÄÂá∫', click: () => app.quit() }
    ]);

    if (tray) {
      tray.setContextMenu(menu);
    } else {
      const iconPath = getResourcePath('public/icon.png');
      tray = new Tray(iconPath); // try-catch protects this
      tray.setToolTip('ScreenCap Pro');
      tray.setContextMenu(menu);
    }
  } catch (e) {
    console.error('createTray failed:', e);
    // Fallback: don't crash main process
  }
}

// IPC Handlers
ipcMain.handle('get-settings', () => settings);

ipcMain.handle('get-screen-source-id', async () => {
  const sources = await desktopCapturer.getSources({ types: ['screen'] });
  return sources[0]?.id;
});

ipcMain.handle('capture-region', async (_event, rect, mode, mousePos) => {
  console.log(`[Main] capture-region called. Mode: ${mode}, Rect:`, rect);

  // ÂÖà‰øùÂ≠òÁºìÂ≠òÁöÑÂºïÁî®ÔºåÂõ†‰∏∫ closeSelectorWindow ‰ºöÊ∏ÖÈô§ÂÆÉ
  const screenshot = cachedScreenshot;

  closeSelectorWindow();

  try {
    const display = screen.getPrimaryDisplay();
    const { width, height } = display.bounds;

    let img: Electron.NativeImage;
    let scaleX: number;
    let scaleY: number;

    // ‰ºòÂÖà‰ΩøÁî®ÁºìÂ≠òÁöÑÊà™ÂõæÔºàF1/F2 ÂÜªÁªìÊ®°ÂºèÔºâ
    if (screenshot && screenshot.nativeImage) {
      console.log('[Main] Using cached screenshot for crop');
      img = screenshot.nativeImage;
      const imgSize = img.getSize();
      scaleX = imgSize.width / screenshot.width;
      scaleY = imgSize.height / screenshot.height;
    } else {
      // ÂõûÈÄÄÔºöÈáçÊñ∞Êà™ÂèñÔºàÁêÜËÆ∫‰∏ä‰∏çÂ∫îËØ•Ëµ∞Âà∞ËøôÈáåÔºâ
      console.log('[Main] No cached screenshot, capturing now');
      await new Promise(resolve => setTimeout(resolve, 50));

      const thumbSize = {
        width: width * display.scaleFactor,
        height: height * display.scaleFactor
      };

      const sources = await desktopCapturer.getSources({
        types: ['screen'],
        thumbnailSize: thumbSize
      });

      if (!sources[0]) throw new Error('No screen source');

      img = sources[0].thumbnail;
      const imgSize = img.getSize();
      scaleX = imgSize.width / width;
      scaleY = imgSize.height / height;
    }

    const cropRect = {
      x: Math.round(rect.x * scaleX),
      y: Math.round(rect.y * scaleY),
      width: Math.round(rect.width * scaleX),
      height: Math.round(rect.height * scaleY)
    };

    const cropped = img.crop(cropRect);

    if (mode === 'clipboard') {
      clipboard.writeImage(cropped);
      showNotification('Â∑≤Â§çÂà∂', { x: width / 2, y: height / 2 });
    } else if (mode === 'file') {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('.')[0];
      const filepath = path.join(settings.savePath, `screenshot-${timestamp}.png`);
      fs.writeFileSync(filepath, cropped.toPNG());
      showNotification('Â∑≤‰øùÂ≠ò', { x: width / 2, y: height / 2 });
    }
    return 'success';
  } catch (e) {
    console.error(e);
    throw e;
  }
});

import { createRequire } from 'module';
const require = createRequire(import.meta.url);

// Worker ÂΩïÂà∂ÈÄªËæë
ipcMain.handle('start-recording-worker', async (_e, rect) => {
  console.log('[Main] start-recording-worker called', rect);

  if (recorderWindow && !recorderWindow.isDestroyed()) {
    recorderWindow.destroy();
    recorderWindow = null;
  }

  createRecorderWindow();

  await new Promise<void>((resolve) => {
    recorderWindow!.webContents.once('did-finish-load', () => {
      setTimeout(() => {
        resolve();
      }, 100);
    });
  });

  isRecording = true;
  recorderWindow?.webContents.send('start-recording', rect, settings);
});

ipcMain.handle('stop-recording-worker', () => {
  recorderWindow?.webContents.send('stop-recording');
});

ipcMain.handle('recording-finished', async (_e, buffer) => {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('.')[0];
  const { width, height } = screen.getPrimaryDisplay().bounds;
  const debugLogPath = path.join(settings.savePath, `debug-${timestamp}.log`);

  const logDebug = (msg: string) => {
    console.log(msg);
    try { fs.appendFileSync(debugLogPath, `[${new Date().toISOString()}] ${msg}\n`); } catch (e) { }
  };

  isRecording = false;

  const bufLength = buffer ? (buffer.length !== undefined ? buffer.length : buffer.byteLength) : 0;

  if (!buffer || bufLength === 0) {
    showNotification('ÂΩïÂà∂Â§±Ë¥•ÔºöÊï∞ÊçÆ‰∏∫Á©∫', { x: width / 2, y: height / 2 });
    return;
  }

  showNotification('Ê≠£Âú®‰øùÂ≠òÔºöÂÜôÂÖ•Êñá‰ª∂...', { x: width / 2, y: height / 2 });

  const webmPath = path.join(settings.savePath, `recording-${timestamp}.webm`);

  try {
    fs.writeFileSync(webmPath, Buffer.from(buffer));
    await new Promise(resolve => setTimeout(resolve, 500));
  } catch (err) {
    showNotification('‰øùÂ≠òÂ§±Ë¥•Ôºö‰∏¥Êó∂Êñá‰ª∂ÂÜôÂÖ•ÈîôËØØ', { x: width / 2, y: height / 2 });
    return;
  }

  if (settings.videoFormat === 'mp4') {
    const mp4Path = path.join(settings.savePath, `recording-${timestamp}.mp4`);
    showNotification('Ê≠£Âú®‰øùÂ≠òÔºöÂºÄÂßãËΩ¨Á†Å...', { x: width / 2, y: height / 2 });

    try {
      // DYNAMIC LOAD: Prevent startup crash
      const ffmpeg = require('fluent-ffmpeg');
      let staticPath = require('ffmpeg-static');
      if (typeof staticPath !== 'string' && staticPath.path) staticPath = staticPath.path;

      let ffmpegPath = staticPath;
      if (app.isPackaged) {
        ffmpegPath = staticPath.replace('app.asar', 'app.asar.unpacked');
      }

      ffmpeg.setFfmpegPath(ffmpegPath);

      await new Promise((resolve, reject) => {
        ffmpeg(webmPath)
          .inputOption('-fflags +genpts')
          .videoCodec('libx264')
          .addOutputOption('-preset', 'ultrafast')
          .save(mp4Path)
          .on('end', () => {
            resolve(null);
          })
          .on('error', (err: any) => {
            reject(err);
          });
      });

      showNotification('‰øùÂ≠òÊàêÂäü (MP4+WebM)', { x: width / 2, y: height / 2 });

    } catch (e: any) {
      logDebug(`Conversion failed: ${e.message}`);
      showNotification('ËΩ¨Á†ÅÂ§±Ë¥•ÔºåÂ∑≤‰øùÂ≠òWebM', { x: width / 2, y: height / 2 });
    }
  } else {
    showNotification('‰øùÂ≠òÊàêÂäü (WebM)', { x: width / 2, y: height / 2 });
  }
});

ipcMain.handle('close-selector', () => {
  isRecording = false;
  closeSelectorWindow();
});

ipcMain.on('set-ignore-mouse-events', (event, ignore, options) => {
  const win = BrowserWindow.fromWebContents(event.sender);
  if (win) {
    if (ignore) {
      win.setIgnoreMouseEvents(true, { forward: true });
    } else {
      win.setIgnoreMouseEvents(false);
    }
  }
});

app.whenReady().then(() => {
  try {
    registerShortcuts();
    createTray();
    createRecorderWindow();

    // È¢ÑÁÉ≠ÈÄâÊã©Âô®Á™óÂè£ÔºàÂä†Âø´ F1/F2 ÂìçÂ∫îÈÄüÂ∫¶Ôºâ
    createPrewarmedSelectorWindow();

    session.defaultSession.setDisplayMediaRequestHandler((request, callback) => {
      desktopCapturer.getSources({ types: ['screen'] }).then((sources) => {
        callback({ video: sources[0], audio: 'loopback' });
      });
    });
  } catch (e) {
    console.error('AppReady error:', e);
  }
});

app.on('render-process-gone', (event, webContents, details) => {
  console.error('Render process gone:', details.reason, details.exitCode);
});

app.on('will-quit', () => {
  if (app.isReady()) {
    globalShortcut.unregisterAll();
  }
  if (tray) {
    tray.destroy();
    tray = null;
  }
});

app.on('window-all-closed', () => {
  if (process.platform === 'darwin') {
    app.dock?.hide();
  }
});
